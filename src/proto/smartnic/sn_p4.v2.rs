// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsMetricScope {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub block: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatsMetricValue {
    #[prost(uint64, tag = "1")]
    pub u64: u64,
    #[prost(double, tag = "2")]
    pub f64: f64,
    /// Used to distinguish values for array metrics.
    #[prost(uint32, tag = "3")]
    pub index: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsMetric {
    #[prost(enumeration = "StatsMetricType", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub scope: ::core::option::Option<StatsMetricScope>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Indicates the metric is a singleton when 0, an array otherwise.
    #[prost(uint32, tag = "4")]
    pub num_elements: u32,
    /// Will contain one value for singleton metrics and be a
    #[prost(message, repeated, tag = "5")]
    pub values: ::prost::alloc::vec::Vec<StatsMetricValue>,
    /// list of values for array metrics.
    ///
    /// Monotonic timestamp indicating when the metric was
    #[prost(message, optional, tag = "6")]
    pub last_update: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stats {
    #[prost(message, repeated, tag = "1")]
    pub metrics: ::prost::alloc::vec::Vec<StatsMetric>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsFilters {
    /// Restrict metrics to the given type(s).
    #[prost(enumeration = "StatsMetricType", repeated, tag = "1")]
    pub metric_types: ::prost::alloc::vec::Vec<i32>,
    /// Leave unset for all types.
    ///
    /// Restrict metrics to those whose value is not zero.
    #[prost(bool, tag = "2")]
    pub non_zero: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// Filters to restrict statistics on get operations.
    #[prost(message, optional, tag = "2")]
    pub filters: ::core::option::Option<StatsFilters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(message, optional, tag = "3")]
    pub stats: ::core::option::Option<Stats>,
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DevicePciInfo {
    #[prost(string, tag = "1")]
    pub bus_id: ::prost::alloc::string::String,
    /// Only low 16-bits are valid (uint16 not supported by protobuf).
    #[prost(uint32, tag = "2")]
    pub vendor_id: u32,
    /// Only low 16-bits are valid (uint16 not supported by protobuf).
    #[prost(uint32, tag = "3")]
    pub device_id: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceBuildInfo {
    /// Value from syscfg.usr_access.
    #[prost(uint32, tag = "1")]
    pub number: u32,
    /// Value from syscfg.build_status.
    #[prost(uint32, tag = "2")]
    pub status: u32,
    /// Array of length 3, value from syscfg.dna\[3\] (same ordering).
    #[prost(uint32, repeated, tag = "3")]
    pub dna: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
    #[prost(message, optional, tag = "1")]
    pub pci: ::core::option::Option<DevicePciInfo>,
    #[prost(message, optional, tag = "2")]
    pub build: ::core::option::Option<DeviceBuildInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceInfoRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfoResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(message, optional, tag = "3")]
    pub info: ::core::option::Option<DeviceInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchInfo {
    #[prost(enumeration = "MatchType", tag = "1")]
    pub r#type: i32,
    #[prost(uint32, tag = "2")]
    pub width: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionParameterInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub width: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub width: u32,
    #[prost(message, repeated, tag = "3")]
    pub parameters: ::prost::alloc::vec::Vec<ActionParameterInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub num_entries: u32,
    #[prost(enumeration = "TableEndian", tag = "3")]
    pub endian: i32,
    #[prost(enumeration = "TableMode", tag = "4")]
    pub mode: i32,
    /// Only valid when mode is TABLE_MODE_STCAM.
    #[prost(uint32, tag = "5")]
    pub num_masks: u32,
    #[prost(bool, tag = "6")]
    pub priority_required: bool,
    #[prost(uint32, tag = "10")]
    pub key_width: u32,
    #[prost(uint32, tag = "11")]
    pub response_width: u32,
    /// Special case: 255 (0xff) means width is automatically computed.
    #[prost(uint32, tag = "12")]
    pub priority_width: u32,
    #[prost(uint32, tag = "13")]
    pub action_id_width: u32,
    #[prost(message, repeated, tag = "20")]
    pub matches: ::prost::alloc::vec::Vec<MatchInfo>,
    #[prost(message, repeated, tag = "21")]
    pub actions: ::prost::alloc::vec::Vec<ActionInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CounterBlockInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "CounterType", tag = "2")]
    pub r#type: i32,
    #[prost(uint32, tag = "3")]
    pub width: u32,
    #[prost(uint32, tag = "4")]
    pub num_counters: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub tables: ::prost::alloc::vec::Vec<TableInfo>,
    #[prost(message, repeated, tag = "3")]
    pub counter_blocks: ::prost::alloc::vec::Vec<CounterBlockInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PipelineInfoRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all pipelines.
    #[prost(sint32, tag = "2")]
    pub pipeline_id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineInfoResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub pipeline_id: u32,
    #[prost(message, optional, tag = "4")]
    pub info: ::core::option::Option<PipelineInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineStatsRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all pipelines.
    #[prost(sint32, tag = "2")]
    pub pipeline_id: i32,
    /// Filters to restrict statistics on get operations.
    #[prost(message, optional, tag = "3")]
    pub filters: ::core::option::Option<StatsFilters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineStatsResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub pipeline_id: u32,
    #[prost(message, optional, tag = "4")]
    pub stats: ::core::option::Option<Stats>,
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all pipelines.
    #[prost(sint32, tag = "2")]
    pub pipeline_id: i32,
    /// Table to operate on. Leave empty for all tables.
    #[prost(string, tag = "3")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TableResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub pipeline_id: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchKeyMask {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mask: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchKeyOnly {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchKeyPrefix {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub prefix_length: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchRange {
    #[prost(uint32, tag = "1")]
    pub lower: u32,
    #[prost(uint32, tag = "2")]
    pub upper: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Match {
    #[prost(oneof = "r#match::Type", tags = "1, 2, 3, 4, 5")]
    pub r#type: ::core::option::Option<r#match::Type>,
}
/// Nested message and enum types in `Match`.
pub mod r#match {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        KeyMask(super::MatchKeyMask),
        #[prost(message, tag = "2")]
        KeyOnly(super::MatchKeyOnly),
        #[prost(message, tag = "3")]
        KeyPrefix(super::MatchKeyPrefix),
        #[prost(message, tag = "4")]
        Range(super::MatchRange),
        #[prost(bool, tag = "5")]
        Unused(bool),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionParameter {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub parameters: ::prost::alloc::vec::Vec<ActionParameter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRule {
    #[prost(string, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
    /// Only used for insert operation.
    #[prost(uint32, tag = "2")]
    pub priority: u32,
    /// Only used for insert operation.
    #[prost(bool, tag = "3")]
    pub replace: bool,
    #[prost(message, repeated, tag = "4")]
    pub matches: ::prost::alloc::vec::Vec<Match>,
    /// Leave unset for delete operation.
    #[prost(message, optional, tag = "5")]
    pub action: ::core::option::Option<Action>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRuleRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all pipelines.
    #[prost(sint32, tag = "2")]
    pub pipeline_id: i32,
    #[prost(message, repeated, tag = "3")]
    pub rules: ::prost::alloc::vec::Vec<TableRule>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TableRuleResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub pipeline_id: u32,
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerStatus {
    /// UTC wall clock.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Diff of monotonic system clock.
    #[prost(message, optional, tag = "2")]
    pub up_time: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerStatusRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerStatusResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<ServerStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerDebug {
    #[prost(enumeration = "ServerDebugFlag", repeated, tag = "1")]
    pub enables: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "ServerDebugFlag", repeated, tag = "2")]
    pub disables: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfig {
    #[prost(message, optional, tag = "1")]
    pub debug: ::core::option::Option<ServerDebug>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfigRequest {
    /// Configuration data used for set operations. Leave unset for get operations.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<ServerConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfigResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    /// Configuration data returned on get operations. Will be unset for set operations.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<ServerConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchRequest {
    #[prost(enumeration = "BatchOperation", tag = "1")]
    pub op: i32,
    #[prost(oneof = "batch_request::Item", tags = "10, 20, 21, 30, 31, 40, 50, 51")]
    pub item: ::core::option::Option<batch_request::Item>,
}
/// Nested message and enum types in `BatchRequest`.
pub mod batch_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        /// Device configuration.
        #[prost(message, tag = "10")]
        DeviceInfo(super::DeviceInfoRequest),
        /// Pipeline configuration.
        #[prost(message, tag = "20")]
        PipelineInfo(super::PipelineInfoRequest),
        #[prost(message, tag = "21")]
        PipelineStats(super::PipelineStatsRequest),
        /// Table configuration.
        #[prost(message, tag = "30")]
        Table(super::TableRequest),
        #[prost(message, tag = "31")]
        TableRule(super::TableRuleRequest),
        /// Statistics configuration.
        #[prost(message, tag = "40")]
        Stats(super::StatsRequest),
        /// Server configuration.
        #[prost(message, tag = "50")]
        ServerStatus(super::ServerStatusRequest),
        #[prost(message, tag = "51")]
        ServerConfig(super::ServerConfigRequest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(enumeration = "BatchOperation", tag = "2")]
    pub op: i32,
    #[prost(oneof = "batch_response::Item", tags = "10, 20, 21, 30, 31, 40, 50, 51")]
    pub item: ::core::option::Option<batch_response::Item>,
}
/// Nested message and enum types in `BatchResponse`.
pub mod batch_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        /// Device configuration.
        #[prost(message, tag = "10")]
        DeviceInfo(super::DeviceInfoResponse),
        /// Pipeline configuration.
        #[prost(message, tag = "20")]
        PipelineInfo(super::PipelineInfoResponse),
        #[prost(message, tag = "21")]
        PipelineStats(super::PipelineStatsResponse),
        /// Table configuration.
        #[prost(message, tag = "30")]
        Table(super::TableResponse),
        #[prost(message, tag = "31")]
        TableRule(super::TableRuleResponse),
        /// Statistics configuration.
        #[prost(message, tag = "40")]
        Stats(super::StatsResponse),
        /// Server configuration.
        #[prost(message, tag = "50")]
        ServerStatus(super::ServerStatusResponse),
        #[prost(message, tag = "51")]
        ServerConfig(super::ServerConfigResponse),
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    /// General error codes.
    ///
    /// Field is unset.
    EcUnknown = 0,
    EcOk = 1,
    /// Batch error codes.
    EcUnknownBatchRequest = 100,
    EcUnknownBatchOp = 101,
    /// Device configuration error codes.
    EcInvalidDeviceId = 200,
    /// Pipeline configuration error codes.
    EcInvalidPipelineId = 300,
    /// Table configuration error codes.
    EcInvalidTableName = 400,
    EcFailedClearAllTables = 401,
    EcFailedClearTable = 402,
    EcInvalidActionName = 403,
    EcTableRuleTooFewMatches = 404,
    EcTableRuleTooManyMatches = 405,
    EcTableRuleTooFewActionParameters = 406,
    EcTableRuleTooManyActionParameters = 407,
    EcTableRuleInvalidActionParameterFormat = 408,
    EcTableRuleMatchInvalidKeyFormat = 409,
    EcTableRuleMatchInvalidMaskFormat = 410,
    EcTableRuleMatchInvalidPrefixLength = 411,
    EcTableRuleMatchRangeLowerTooBig = 412,
    EcTableRuleMatchRangeUpperTooBig = 413,
    EcUnknownTableRuleMatchType = 414,
    EcFailedInsertTableRule = 415,
    EcFailedDeleteTableRule = 416,
    EcTableRuleFieldSpecOverflow = 450,
    EcTableRuleFieldSpecFormatInvalid = 451,
    EcTableRuleFieldSpecUnknownType = 452,
    EcTableRuleFieldSpecSizeMismatch = 453,
    EcTableRulePackKeyTooBig = 454,
    EcTableRulePackMaskTooBig = 455,
    EcTableRulePackParamsTooBig = 456,
    EcTableRuleMatchInvalidFormat = 457,
    EcTableRuleMatchMaskTooWide = 458,
    EcTableRuleMatchInvalidBitfieldMask = 459,
    EcTableRuleMatchInvalidConstantMask = 460,
    EcTableRuleMatchInvalidPrefixMask = 461,
    EcTableRuleMatchInvalidRangeMask = 462,
    EcTableRuleMatchInvalidUnusedMask = 463,
    EcTableRuleMatchKeyTooBig = 464,
    EcTableRuleMatchMaskTooBig = 465,
    EcTableRuleInvalidTableName = 466,
    EcTableRuleInvalidTableConfig = 467,
    EcTableRuleInvalidActionForTable = 468,
    EcTableRuleParamInvalidFormat = 469,
    EcTableRuleParamSpecOverflow = 470,
    EcTableRuleParamSpecSizeMismatch = 471,
    EcTableRuleParamTooBig = 472,
    /// Server configuration error codes.
    EcServerFailedGetTime = 500,
    EcServerInvalidDebugFlag = 501,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EcUnknown => "EC_UNKNOWN",
            Self::EcOk => "EC_OK",
            Self::EcUnknownBatchRequest => "EC_UNKNOWN_BATCH_REQUEST",
            Self::EcUnknownBatchOp => "EC_UNKNOWN_BATCH_OP",
            Self::EcInvalidDeviceId => "EC_INVALID_DEVICE_ID",
            Self::EcInvalidPipelineId => "EC_INVALID_PIPELINE_ID",
            Self::EcInvalidTableName => "EC_INVALID_TABLE_NAME",
            Self::EcFailedClearAllTables => "EC_FAILED_CLEAR_ALL_TABLES",
            Self::EcFailedClearTable => "EC_FAILED_CLEAR_TABLE",
            Self::EcInvalidActionName => "EC_INVALID_ACTION_NAME",
            Self::EcTableRuleTooFewMatches => "EC_TABLE_RULE_TOO_FEW_MATCHES",
            Self::EcTableRuleTooManyMatches => "EC_TABLE_RULE_TOO_MANY_MATCHES",
            Self::EcTableRuleTooFewActionParameters => {
                "EC_TABLE_RULE_TOO_FEW_ACTION_PARAMETERS"
            }
            Self::EcTableRuleTooManyActionParameters => {
                "EC_TABLE_RULE_TOO_MANY_ACTION_PARAMETERS"
            }
            Self::EcTableRuleInvalidActionParameterFormat => {
                "EC_TABLE_RULE_INVALID_ACTION_PARAMETER_FORMAT"
            }
            Self::EcTableRuleMatchInvalidKeyFormat => {
                "EC_TABLE_RULE_MATCH_INVALID_KEY_FORMAT"
            }
            Self::EcTableRuleMatchInvalidMaskFormat => {
                "EC_TABLE_RULE_MATCH_INVALID_MASK_FORMAT"
            }
            Self::EcTableRuleMatchInvalidPrefixLength => {
                "EC_TABLE_RULE_MATCH_INVALID_PREFIX_LENGTH"
            }
            Self::EcTableRuleMatchRangeLowerTooBig => {
                "EC_TABLE_RULE_MATCH_RANGE_LOWER_TOO_BIG"
            }
            Self::EcTableRuleMatchRangeUpperTooBig => {
                "EC_TABLE_RULE_MATCH_RANGE_UPPER_TOO_BIG"
            }
            Self::EcUnknownTableRuleMatchType => "EC_UNKNOWN_TABLE_RULE_MATCH_TYPE",
            Self::EcFailedInsertTableRule => "EC_FAILED_INSERT_TABLE_RULE",
            Self::EcFailedDeleteTableRule => "EC_FAILED_DELETE_TABLE_RULE",
            Self::EcTableRuleFieldSpecOverflow => "EC_TABLE_RULE_FIELD_SPEC_OVERFLOW",
            Self::EcTableRuleFieldSpecFormatInvalid => {
                "EC_TABLE_RULE_FIELD_SPEC_FORMAT_INVALID"
            }
            Self::EcTableRuleFieldSpecUnknownType => {
                "EC_TABLE_RULE_FIELD_SPEC_UNKNOWN_TYPE"
            }
            Self::EcTableRuleFieldSpecSizeMismatch => {
                "EC_TABLE_RULE_FIELD_SPEC_SIZE_MISMATCH"
            }
            Self::EcTableRulePackKeyTooBig => "EC_TABLE_RULE_PACK_KEY_TOO_BIG",
            Self::EcTableRulePackMaskTooBig => "EC_TABLE_RULE_PACK_MASK_TOO_BIG",
            Self::EcTableRulePackParamsTooBig => "EC_TABLE_RULE_PACK_PARAMS_TOO_BIG",
            Self::EcTableRuleMatchInvalidFormat => "EC_TABLE_RULE_MATCH_INVALID_FORMAT",
            Self::EcTableRuleMatchMaskTooWide => "EC_TABLE_RULE_MATCH_MASK_TOO_WIDE",
            Self::EcTableRuleMatchInvalidBitfieldMask => {
                "EC_TABLE_RULE_MATCH_INVALID_BITFIELD_MASK"
            }
            Self::EcTableRuleMatchInvalidConstantMask => {
                "EC_TABLE_RULE_MATCH_INVALID_CONSTANT_MASK"
            }
            Self::EcTableRuleMatchInvalidPrefixMask => {
                "EC_TABLE_RULE_MATCH_INVALID_PREFIX_MASK"
            }
            Self::EcTableRuleMatchInvalidRangeMask => {
                "EC_TABLE_RULE_MATCH_INVALID_RANGE_MASK"
            }
            Self::EcTableRuleMatchInvalidUnusedMask => {
                "EC_TABLE_RULE_MATCH_INVALID_UNUSED_MASK"
            }
            Self::EcTableRuleMatchKeyTooBig => "EC_TABLE_RULE_MATCH_KEY_TOO_BIG",
            Self::EcTableRuleMatchMaskTooBig => "EC_TABLE_RULE_MATCH_MASK_TOO_BIG",
            Self::EcTableRuleInvalidTableName => "EC_TABLE_RULE_INVALID_TABLE_NAME",
            Self::EcTableRuleInvalidTableConfig => "EC_TABLE_RULE_INVALID_TABLE_CONFIG",
            Self::EcTableRuleInvalidActionForTable => {
                "EC_TABLE_RULE_INVALID_ACTION_FOR_TABLE"
            }
            Self::EcTableRuleParamInvalidFormat => "EC_TABLE_RULE_PARAM_INVALID_FORMAT",
            Self::EcTableRuleParamSpecOverflow => "EC_TABLE_RULE_PARAM_SPEC_OVERFLOW",
            Self::EcTableRuleParamSpecSizeMismatch => {
                "EC_TABLE_RULE_PARAM_SPEC_SIZE_MISMATCH"
            }
            Self::EcTableRuleParamTooBig => "EC_TABLE_RULE_PARAM_TOO_BIG",
            Self::EcServerFailedGetTime => "EC_SERVER_FAILED_GET_TIME",
            Self::EcServerInvalidDebugFlag => "EC_SERVER_INVALID_DEBUG_FLAG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EC_UNKNOWN" => Some(Self::EcUnknown),
            "EC_OK" => Some(Self::EcOk),
            "EC_UNKNOWN_BATCH_REQUEST" => Some(Self::EcUnknownBatchRequest),
            "EC_UNKNOWN_BATCH_OP" => Some(Self::EcUnknownBatchOp),
            "EC_INVALID_DEVICE_ID" => Some(Self::EcInvalidDeviceId),
            "EC_INVALID_PIPELINE_ID" => Some(Self::EcInvalidPipelineId),
            "EC_INVALID_TABLE_NAME" => Some(Self::EcInvalidTableName),
            "EC_FAILED_CLEAR_ALL_TABLES" => Some(Self::EcFailedClearAllTables),
            "EC_FAILED_CLEAR_TABLE" => Some(Self::EcFailedClearTable),
            "EC_INVALID_ACTION_NAME" => Some(Self::EcInvalidActionName),
            "EC_TABLE_RULE_TOO_FEW_MATCHES" => Some(Self::EcTableRuleTooFewMatches),
            "EC_TABLE_RULE_TOO_MANY_MATCHES" => Some(Self::EcTableRuleTooManyMatches),
            "EC_TABLE_RULE_TOO_FEW_ACTION_PARAMETERS" => {
                Some(Self::EcTableRuleTooFewActionParameters)
            }
            "EC_TABLE_RULE_TOO_MANY_ACTION_PARAMETERS" => {
                Some(Self::EcTableRuleTooManyActionParameters)
            }
            "EC_TABLE_RULE_INVALID_ACTION_PARAMETER_FORMAT" => {
                Some(Self::EcTableRuleInvalidActionParameterFormat)
            }
            "EC_TABLE_RULE_MATCH_INVALID_KEY_FORMAT" => {
                Some(Self::EcTableRuleMatchInvalidKeyFormat)
            }
            "EC_TABLE_RULE_MATCH_INVALID_MASK_FORMAT" => {
                Some(Self::EcTableRuleMatchInvalidMaskFormat)
            }
            "EC_TABLE_RULE_MATCH_INVALID_PREFIX_LENGTH" => {
                Some(Self::EcTableRuleMatchInvalidPrefixLength)
            }
            "EC_TABLE_RULE_MATCH_RANGE_LOWER_TOO_BIG" => {
                Some(Self::EcTableRuleMatchRangeLowerTooBig)
            }
            "EC_TABLE_RULE_MATCH_RANGE_UPPER_TOO_BIG" => {
                Some(Self::EcTableRuleMatchRangeUpperTooBig)
            }
            "EC_UNKNOWN_TABLE_RULE_MATCH_TYPE" => Some(Self::EcUnknownTableRuleMatchType),
            "EC_FAILED_INSERT_TABLE_RULE" => Some(Self::EcFailedInsertTableRule),
            "EC_FAILED_DELETE_TABLE_RULE" => Some(Self::EcFailedDeleteTableRule),
            "EC_TABLE_RULE_FIELD_SPEC_OVERFLOW" => {
                Some(Self::EcTableRuleFieldSpecOverflow)
            }
            "EC_TABLE_RULE_FIELD_SPEC_FORMAT_INVALID" => {
                Some(Self::EcTableRuleFieldSpecFormatInvalid)
            }
            "EC_TABLE_RULE_FIELD_SPEC_UNKNOWN_TYPE" => {
                Some(Self::EcTableRuleFieldSpecUnknownType)
            }
            "EC_TABLE_RULE_FIELD_SPEC_SIZE_MISMATCH" => {
                Some(Self::EcTableRuleFieldSpecSizeMismatch)
            }
            "EC_TABLE_RULE_PACK_KEY_TOO_BIG" => Some(Self::EcTableRulePackKeyTooBig),
            "EC_TABLE_RULE_PACK_MASK_TOO_BIG" => Some(Self::EcTableRulePackMaskTooBig),
            "EC_TABLE_RULE_PACK_PARAMS_TOO_BIG" => {
                Some(Self::EcTableRulePackParamsTooBig)
            }
            "EC_TABLE_RULE_MATCH_INVALID_FORMAT" => {
                Some(Self::EcTableRuleMatchInvalidFormat)
            }
            "EC_TABLE_RULE_MATCH_MASK_TOO_WIDE" => {
                Some(Self::EcTableRuleMatchMaskTooWide)
            }
            "EC_TABLE_RULE_MATCH_INVALID_BITFIELD_MASK" => {
                Some(Self::EcTableRuleMatchInvalidBitfieldMask)
            }
            "EC_TABLE_RULE_MATCH_INVALID_CONSTANT_MASK" => {
                Some(Self::EcTableRuleMatchInvalidConstantMask)
            }
            "EC_TABLE_RULE_MATCH_INVALID_PREFIX_MASK" => {
                Some(Self::EcTableRuleMatchInvalidPrefixMask)
            }
            "EC_TABLE_RULE_MATCH_INVALID_RANGE_MASK" => {
                Some(Self::EcTableRuleMatchInvalidRangeMask)
            }
            "EC_TABLE_RULE_MATCH_INVALID_UNUSED_MASK" => {
                Some(Self::EcTableRuleMatchInvalidUnusedMask)
            }
            "EC_TABLE_RULE_MATCH_KEY_TOO_BIG" => Some(Self::EcTableRuleMatchKeyTooBig),
            "EC_TABLE_RULE_MATCH_MASK_TOO_BIG" => Some(Self::EcTableRuleMatchMaskTooBig),
            "EC_TABLE_RULE_INVALID_TABLE_NAME" => Some(Self::EcTableRuleInvalidTableName),
            "EC_TABLE_RULE_INVALID_TABLE_CONFIG" => {
                Some(Self::EcTableRuleInvalidTableConfig)
            }
            "EC_TABLE_RULE_INVALID_ACTION_FOR_TABLE" => {
                Some(Self::EcTableRuleInvalidActionForTable)
            }
            "EC_TABLE_RULE_PARAM_INVALID_FORMAT" => {
                Some(Self::EcTableRuleParamInvalidFormat)
            }
            "EC_TABLE_RULE_PARAM_SPEC_OVERFLOW" => {
                Some(Self::EcTableRuleParamSpecOverflow)
            }
            "EC_TABLE_RULE_PARAM_SPEC_SIZE_MISMATCH" => {
                Some(Self::EcTableRuleParamSpecSizeMismatch)
            }
            "EC_TABLE_RULE_PARAM_TOO_BIG" => Some(Self::EcTableRuleParamTooBig),
            "EC_SERVER_FAILED_GET_TIME" => Some(Self::EcServerFailedGetTime),
            "EC_SERVER_INVALID_DEBUG_FLAG" => Some(Self::EcServerInvalidDebugFlag),
            _ => None,
        }
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StatsMetricType {
    /// Field is unset.
    Unknown = 0,
    Counter = 1,
    Gauge = 2,
    Flag = 3,
}
impl StatsMetricType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "STATS_METRIC_TYPE_UNKNOWN",
            Self::Counter => "STATS_METRIC_TYPE_COUNTER",
            Self::Gauge => "STATS_METRIC_TYPE_GAUGE",
            Self::Flag => "STATS_METRIC_TYPE_FLAG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATS_METRIC_TYPE_UNKNOWN" => Some(Self::Unknown),
            "STATS_METRIC_TYPE_COUNTER" => Some(Self::Counter),
            "STATS_METRIC_TYPE_GAUGE" => Some(Self::Gauge),
            "STATS_METRIC_TYPE_FLAG" => Some(Self::Flag),
            _ => None,
        }
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MatchType {
    /// Field is unset.
    Unknown = 0,
    Bitfield = 1,
    Constant = 2,
    Prefix = 3,
    Range = 4,
    Ternary = 5,
    Unused = 6,
}
impl MatchType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "MATCH_TYPE_UNKNOWN",
            Self::Bitfield => "MATCH_TYPE_BITFIELD",
            Self::Constant => "MATCH_TYPE_CONSTANT",
            Self::Prefix => "MATCH_TYPE_PREFIX",
            Self::Range => "MATCH_TYPE_RANGE",
            Self::Ternary => "MATCH_TYPE_TERNARY",
            Self::Unused => "MATCH_TYPE_UNUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATCH_TYPE_UNKNOWN" => Some(Self::Unknown),
            "MATCH_TYPE_BITFIELD" => Some(Self::Bitfield),
            "MATCH_TYPE_CONSTANT" => Some(Self::Constant),
            "MATCH_TYPE_PREFIX" => Some(Self::Prefix),
            "MATCH_TYPE_RANGE" => Some(Self::Range),
            "MATCH_TYPE_TERNARY" => Some(Self::Ternary),
            "MATCH_TYPE_UNUSED" => Some(Self::Unused),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TableEndian {
    /// Field is unset.
    Unknown = 0,
    Little = 1,
    Big = 2,
}
impl TableEndian {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "TABLE_ENDIAN_UNKNOWN",
            Self::Little => "TABLE_ENDIAN_LITTLE",
            Self::Big => "TABLE_ENDIAN_BIG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TABLE_ENDIAN_UNKNOWN" => Some(Self::Unknown),
            "TABLE_ENDIAN_LITTLE" => Some(Self::Little),
            "TABLE_ENDIAN_BIG" => Some(Self::Big),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TableMode {
    /// Field is unset.
    Unknown = 0,
    Bcam = 1,
    Stcam = 2,
    Tcam = 3,
    Dcam = 4,
    TinyBcam = 5,
    TinyTcam = 6,
}
impl TableMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "TABLE_MODE_UNKNOWN",
            Self::Bcam => "TABLE_MODE_BCAM",
            Self::Stcam => "TABLE_MODE_STCAM",
            Self::Tcam => "TABLE_MODE_TCAM",
            Self::Dcam => "TABLE_MODE_DCAM",
            Self::TinyBcam => "TABLE_MODE_TINY_BCAM",
            Self::TinyTcam => "TABLE_MODE_TINY_TCAM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TABLE_MODE_UNKNOWN" => Some(Self::Unknown),
            "TABLE_MODE_BCAM" => Some(Self::Bcam),
            "TABLE_MODE_STCAM" => Some(Self::Stcam),
            "TABLE_MODE_TCAM" => Some(Self::Tcam),
            "TABLE_MODE_DCAM" => Some(Self::Dcam),
            "TABLE_MODE_TINY_BCAM" => Some(Self::TinyBcam),
            "TABLE_MODE_TINY_TCAM" => Some(Self::TinyTcam),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CounterType {
    Unknown = 0,
    Packets = 1,
    Bytes = 2,
    PacketsAndBytes = 3,
    Flag = 4,
}
impl CounterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "COUNTER_TYPE_UNKNOWN",
            Self::Packets => "COUNTER_TYPE_PACKETS",
            Self::Bytes => "COUNTER_TYPE_BYTES",
            Self::PacketsAndBytes => "COUNTER_TYPE_PACKETS_AND_BYTES",
            Self::Flag => "COUNTER_TYPE_FLAG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COUNTER_TYPE_UNKNOWN" => Some(Self::Unknown),
            "COUNTER_TYPE_PACKETS" => Some(Self::Packets),
            "COUNTER_TYPE_BYTES" => Some(Self::Bytes),
            "COUNTER_TYPE_PACKETS_AND_BYTES" => Some(Self::PacketsAndBytes),
            "COUNTER_TYPE_FLAG" => Some(Self::Flag),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServerDebugFlag {
    DebugFlagUnknown = 0,
    DebugFlagTableClear = 1,
    DebugFlagTableRuleInsert = 2,
    DebugFlagTableRuleDelete = 3,
}
impl ServerDebugFlag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DebugFlagUnknown => "DEBUG_FLAG_UNKNOWN",
            Self::DebugFlagTableClear => "DEBUG_FLAG_TABLE_CLEAR",
            Self::DebugFlagTableRuleInsert => "DEBUG_FLAG_TABLE_RULE_INSERT",
            Self::DebugFlagTableRuleDelete => "DEBUG_FLAG_TABLE_RULE_DELETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEBUG_FLAG_UNKNOWN" => Some(Self::DebugFlagUnknown),
            "DEBUG_FLAG_TABLE_CLEAR" => Some(Self::DebugFlagTableClear),
            "DEBUG_FLAG_TABLE_RULE_INSERT" => Some(Self::DebugFlagTableRuleInsert),
            "DEBUG_FLAG_TABLE_RULE_DELETE" => Some(Self::DebugFlagTableRuleDelete),
            _ => None,
        }
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BatchOperation {
    /// Field is unset.
    BopUnknown = 0,
    BopGet = 1,
    BopSet = 2,
    BopClear = 3,
    BopInsert = 4,
    BopDelete = 5,
}
impl BatchOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BopUnknown => "BOP_UNKNOWN",
            Self::BopGet => "BOP_GET",
            Self::BopSet => "BOP_SET",
            Self::BopClear => "BOP_CLEAR",
            Self::BopInsert => "BOP_INSERT",
            Self::BopDelete => "BOP_DELETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOP_UNKNOWN" => Some(Self::BopUnknown),
            "BOP_GET" => Some(Self::BopGet),
            "BOP_SET" => Some(Self::BopSet),
            "BOP_CLEAR" => Some(Self::BopClear),
            "BOP_INSERT" => Some(Self::BopInsert),
            "BOP_DELETE" => Some(Self::BopDelete),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod smartnic_p4_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// --------------------------------------------------------------------------------------------------
    #[derive(Debug, Clone)]
    pub struct SmartnicP4Client<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SmartnicP4Client<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SmartnicP4Client<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SmartnicP4Client<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SmartnicP4Client::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Batching of multiple RPCs.
        pub async fn batch(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::BatchRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BatchResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/Batch",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "Batch"));
            self.inner.streaming(req, path, codec).await
        }
        /// Device configuration.
        pub async fn get_device_info(
            &mut self,
            request: impl tonic::IntoRequest<super::DeviceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DeviceInfoResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/GetDeviceInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "GetDeviceInfo"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Pipeline configuration.
        pub async fn get_pipeline_info(
            &mut self,
            request: impl tonic::IntoRequest<super::PipelineInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PipelineInfoResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/GetPipelineInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "GetPipelineInfo"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_pipeline_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::PipelineStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PipelineStatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/GetPipelineStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "GetPipelineStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn clear_pipeline_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::PipelineStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PipelineStatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/ClearPipelineStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "ClearPipelineStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Table configuration.
        pub async fn clear_table(
            &mut self,
            request: impl tonic::IntoRequest<super::TableRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TableResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/ClearTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "ClearTable"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn insert_table_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::TableRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TableRuleResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/InsertTableRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "InsertTableRule"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn delete_table_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::TableRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TableRuleResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/DeleteTableRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "DeleteTableRule"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Statistics configuration.
        pub async fn get_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::StatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/GetStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "GetStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn clear_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::StatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/ClearStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "ClearStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Server configuration.
        pub async fn get_server_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ServerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ServerConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/GetServerConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "GetServerConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn set_server_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ServerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ServerConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/SetServerConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "SetServerConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_server_status(
            &mut self,
            request: impl tonic::IntoRequest<super::ServerStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ServerStatusResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_p4.v2.SmartnicP4/GetServerStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_p4.v2.SmartnicP4", "GetServerStatus"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod smartnic_p4_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SmartnicP4Server.
    #[async_trait]
    pub trait SmartnicP4: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Batch method.
        type BatchStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::BatchResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Batching of multiple RPCs.
        async fn batch(
            &self,
            request: tonic::Request<tonic::Streaming<super::BatchRequest>>,
        ) -> std::result::Result<tonic::Response<Self::BatchStream>, tonic::Status>;
        /// Server streaming response type for the GetDeviceInfo method.
        type GetDeviceInfoStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DeviceInfoResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Device configuration.
        async fn get_device_info(
            &self,
            request: tonic::Request<super::DeviceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetDeviceInfoStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetPipelineInfo method.
        type GetPipelineInfoStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PipelineInfoResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Pipeline configuration.
        async fn get_pipeline_info(
            &self,
            request: tonic::Request<super::PipelineInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetPipelineInfoStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetPipelineStats method.
        type GetPipelineStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PipelineStatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_pipeline_stats(
            &self,
            request: tonic::Request<super::PipelineStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetPipelineStatsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the ClearPipelineStats method.
        type ClearPipelineStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PipelineStatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn clear_pipeline_stats(
            &self,
            request: tonic::Request<super::PipelineStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ClearPipelineStatsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the ClearTable method.
        type ClearTableStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::TableResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Table configuration.
        async fn clear_table(
            &self,
            request: tonic::Request<super::TableRequest>,
        ) -> std::result::Result<tonic::Response<Self::ClearTableStream>, tonic::Status>;
        /// Server streaming response type for the InsertTableRule method.
        type InsertTableRuleStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::TableRuleResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn insert_table_rule(
            &self,
            request: tonic::Request<super::TableRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::InsertTableRuleStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the DeleteTableRule method.
        type DeleteTableRuleStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::TableRuleResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn delete_table_rule(
            &self,
            request: tonic::Request<super::TableRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::DeleteTableRuleStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetStats method.
        type GetStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::StatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Statistics configuration.
        async fn get_stats(
            &self,
            request: tonic::Request<super::StatsRequest>,
        ) -> std::result::Result<tonic::Response<Self::GetStatsStream>, tonic::Status>;
        /// Server streaming response type for the ClearStats method.
        type ClearStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::StatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn clear_stats(
            &self,
            request: tonic::Request<super::StatsRequest>,
        ) -> std::result::Result<tonic::Response<Self::ClearStatsStream>, tonic::Status>;
        /// Server streaming response type for the GetServerConfig method.
        type GetServerConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ServerConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Server configuration.
        async fn get_server_config(
            &self,
            request: tonic::Request<super::ServerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetServerConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SetServerConfig method.
        type SetServerConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ServerConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn set_server_config(
            &self,
            request: tonic::Request<super::ServerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SetServerConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetServerStatus method.
        type GetServerStatusStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ServerStatusResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_server_status(
            &self,
            request: tonic::Request<super::ServerStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetServerStatusStream>,
            tonic::Status,
        >;
    }
    /// --------------------------------------------------------------------------------------------------
    #[derive(Debug)]
    pub struct SmartnicP4Server<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SmartnicP4Server<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SmartnicP4Server<T>
    where
        T: SmartnicP4,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sn_p4.v2.SmartnicP4/Batch" => {
                    #[allow(non_camel_case_types)]
                    struct BatchSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::StreamingService<super::BatchRequest>
                    for BatchSvc<T> {
                        type Response = super::BatchResponse;
                        type ResponseStream = T::BatchStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::BatchRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::batch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/GetDeviceInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetDeviceInfoSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::DeviceInfoRequest>
                    for GetDeviceInfoSvc<T> {
                        type Response = super::DeviceInfoResponse;
                        type ResponseStream = T::GetDeviceInfoStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeviceInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::get_device_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDeviceInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/GetPipelineInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetPipelineInfoSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::PipelineInfoRequest>
                    for GetPipelineInfoSvc<T> {
                        type Response = super::PipelineInfoResponse;
                        type ResponseStream = T::GetPipelineInfoStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PipelineInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::get_pipeline_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPipelineInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/GetPipelineStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetPipelineStatsSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::PipelineStatsRequest>
                    for GetPipelineStatsSvc<T> {
                        type Response = super::PipelineStatsResponse;
                        type ResponseStream = T::GetPipelineStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PipelineStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::get_pipeline_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPipelineStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/ClearPipelineStats" => {
                    #[allow(non_camel_case_types)]
                    struct ClearPipelineStatsSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::PipelineStatsRequest>
                    for ClearPipelineStatsSvc<T> {
                        type Response = super::PipelineStatsResponse;
                        type ResponseStream = T::ClearPipelineStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PipelineStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::clear_pipeline_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClearPipelineStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/ClearTable" => {
                    #[allow(non_camel_case_types)]
                    struct ClearTableSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::TableRequest>
                    for ClearTableSvc<T> {
                        type Response = super::TableResponse;
                        type ResponseStream = T::ClearTableStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TableRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::clear_table(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClearTableSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/InsertTableRule" => {
                    #[allow(non_camel_case_types)]
                    struct InsertTableRuleSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::TableRuleRequest>
                    for InsertTableRuleSvc<T> {
                        type Response = super::TableRuleResponse;
                        type ResponseStream = T::InsertTableRuleStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TableRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::insert_table_rule(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InsertTableRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/DeleteTableRule" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteTableRuleSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::TableRuleRequest>
                    for DeleteTableRuleSvc<T> {
                        type Response = super::TableRuleResponse;
                        type ResponseStream = T::DeleteTableRuleStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TableRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::delete_table_rule(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteTableRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/GetStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetStatsSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::StatsRequest>
                    for GetStatsSvc<T> {
                        type Response = super::StatsResponse;
                        type ResponseStream = T::GetStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::get_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/ClearStats" => {
                    #[allow(non_camel_case_types)]
                    struct ClearStatsSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::StatsRequest>
                    for ClearStatsSvc<T> {
                        type Response = super::StatsResponse;
                        type ResponseStream = T::ClearStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::clear_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClearStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/GetServerConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetServerConfigSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::ServerConfigRequest>
                    for GetServerConfigSvc<T> {
                        type Response = super::ServerConfigResponse;
                        type ResponseStream = T::GetServerConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServerConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::get_server_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServerConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/SetServerConfig" => {
                    #[allow(non_camel_case_types)]
                    struct SetServerConfigSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::ServerConfigRequest>
                    for SetServerConfigSvc<T> {
                        type Response = super::ServerConfigResponse;
                        type ResponseStream = T::SetServerConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServerConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::set_server_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetServerConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_p4.v2.SmartnicP4/GetServerStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetServerStatusSvc<T: SmartnicP4>(pub Arc<T>);
                    impl<
                        T: SmartnicP4,
                    > tonic::server::ServerStreamingService<super::ServerStatusRequest>
                    for GetServerStatusSvc<T> {
                        type Response = super::ServerStatusResponse;
                        type ResponseStream = T::GetServerStatusStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServerStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicP4>::get_server_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServerStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SmartnicP4Server<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sn_p4.v2.SmartnicP4";
    impl<T> tonic::server::NamedService for SmartnicP4Server<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
