// This file is @generated by prost-build.
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsCounter {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub block: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub value: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsMetricScope {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub block: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatsMetricValue {
    #[prost(uint64, tag = "1")]
    pub u64: u64,
    #[prost(double, tag = "2")]
    pub f64: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsMetric {
    #[prost(enumeration = "StatsMetricType", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub scope: ::core::option::Option<StatsMetricScope>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub value: ::core::option::Option<StatsMetricValue>,
    /// Monotonic timestamp indicating when the metric was
    #[prost(message, optional, tag = "5")]
    pub last_update: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stats {
    /// This field is no longer populated. Use the metrics field instead.
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub counters: ::prost::alloc::vec::Vec<StatsCounter>,
    #[prost(message, repeated, tag = "2")]
    pub metrics: ::prost::alloc::vec::Vec<StatsMetric>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsFilters {
    /// Restrict metrics to the given type(s).
    #[prost(enumeration = "StatsMetricType", repeated, tag = "1")]
    pub metric_types: ::prost::alloc::vec::Vec<i32>,
    /// Leave unset for all types.
    ///
    /// Restrict metrics to those whose value is not zero.
    #[prost(bool, tag = "2")]
    pub non_zero: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// Filters to restrict statistics on get operations.
    #[prost(message, optional, tag = "2")]
    pub filters: ::core::option::Option<StatsFilters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(message, optional, tag = "3")]
    pub stats: ::core::option::Option<Stats>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DefaultsRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    #[prost(enumeration = "DefaultsProfile", tag = "2")]
    pub profile: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DefaultsResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DevicePciInfo {
    #[prost(string, tag = "1")]
    pub bus_id: ::prost::alloc::string::String,
    /// Only low 16-bits are valid (uint16 not supported by protobuf).
    #[prost(uint32, tag = "2")]
    pub vendor_id: u32,
    /// Only low 16-bits are valid (uint16 not supported by protobuf).
    #[prost(uint32, tag = "3")]
    pub device_id: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceBuildInfo {
    /// Value from syscfg.usr_access.
    #[prost(uint32, tag = "1")]
    pub number: u32,
    /// Value from syscfg.build_status.
    #[prost(uint32, tag = "2")]
    pub status: u32,
    /// Array of length 3, value from syscfg.dna\[3\] (same ordering).
    #[prost(uint32, repeated, tag = "3")]
    pub dna: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceCardInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub profile: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub revision: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub sc_version: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub fan_presence: ::prost::alloc::string::String,
    /// in Watts
    #[prost(uint32, tag = "11")]
    pub total_power_avail: u32,
    #[prost(string, tag = "12")]
    pub config_mode: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "20")]
    pub cage_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "30")]
    pub mac_addrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
    #[prost(message, optional, tag = "1")]
    pub pci: ::core::option::Option<DevicePciInfo>,
    #[prost(message, optional, tag = "2")]
    pub build: ::core::option::Option<DeviceBuildInfo>,
    #[prost(message, optional, tag = "3")]
    pub card: ::core::option::Option<DeviceCardInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceInfoRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfoResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(message, optional, tag = "3")]
    pub info: ::core::option::Option<DeviceInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceSystemMonitor {
    /// System monitor index.
    #[prost(uint32, tag = "1")]
    pub index: u32,
    /// Value from sysmon0.temperature.
    #[prost(float, tag = "2")]
    pub temperature: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceStatusAlarm {
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub active: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceStatusMonitor {
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub value: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceStatus {
    /// This field is no longer populated. Use the monitors field with:
    /// - source == "sysmon<index>" ("sysmon0", "sysmon1", ...)
    /// - name == "temp"
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub sysmons: ::prost::alloc::vec::Vec<DeviceSystemMonitor>,
    #[prost(message, repeated, tag = "2")]
    pub monitors: ::prost::alloc::vec::Vec<DeviceStatusMonitor>,
    #[prost(message, repeated, tag = "3")]
    pub alarms: ::prost::alloc::vec::Vec<DeviceStatusAlarm>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceStatusRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceStatusResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<DeviceStatus>,
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostDmaConfig {
    #[prost(uint32, tag = "1")]
    pub base_queue: u32,
    #[prost(uint32, tag = "2")]
    pub num_queues: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostConfig {
    #[prost(message, optional, tag = "1")]
    pub dma: ::core::option::Option<HostDmaConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostConfigRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all host interfaces.
    #[prost(sint32, tag = "2")]
    pub host_id: i32,
    /// Configuration data used for set operations. Leave unset for get operations.
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<HostConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostConfigResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub host_id: u32,
    /// Configuration data returned on get operations. Will be unset for set operations.
    #[prost(message, optional, tag = "4")]
    pub config: ::core::option::Option<HostConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostStatsRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all host interfaces.
    #[prost(sint32, tag = "2")]
    pub host_id: i32,
    /// Filters to restrict statistics on get operations.
    #[prost(message, optional, tag = "3")]
    pub filters: ::core::option::Option<StatsFilters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostStatsResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub host_id: u32,
    #[prost(message, optional, tag = "4")]
    pub stats: ::core::option::Option<Stats>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModuleGpio {
    /// An enum is used instead of a bool in order to allow the server to detect which GPIOs
    /// are being modified during set operations.
    ///
    /// read/write
    #[prost(enumeration = "ModuleGpioState", tag = "1")]
    pub reset: i32,
    /// read/write
    #[prost(enumeration = "ModuleGpioState", tag = "2")]
    pub low_power_mode: i32,
    /// read-only
    #[prost(enumeration = "ModuleGpioState", tag = "3")]
    pub select: i32,
    /// read-only
    #[prost(enumeration = "ModuleGpioState", tag = "4")]
    pub present: i32,
    /// read-only
    #[prost(enumeration = "ModuleGpioState", tag = "5")]
    pub interrupt: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModuleGpioRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all modules.
    #[prost(sint32, tag = "2")]
    pub mod_id: i32,
    /// Configuration data used for set operations. Leave unset for get operations.
    #[prost(message, optional, tag = "3")]
    pub gpio: ::core::option::Option<ModuleGpio>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModuleGpioResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub mod_id: u32,
    /// Configuration data returned on get operations. Will be unset for set operations.
    #[prost(message, optional, tag = "4")]
    pub gpio: ::core::option::Option<ModuleGpio>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfoVendorDate {
    #[prost(string, tag = "1")]
    pub year: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub month: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub day: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub vendor: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfoVendor {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub oui: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub revision: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub part_number: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub clei: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub date: ::core::option::Option<ModuleInfoVendorDate>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfoSpecComplianceFibre {
    /// List of support fibre lengths. May be empty.
    #[prost(string, repeated, tag = "1")]
    pub length: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of support fibre Tx technology types. May be empty.
    #[prost(string, repeated, tag = "2")]
    pub tx_technology: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of support fibre media types. May be empty.
    #[prost(string, repeated, tag = "3")]
    pub media: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of support fibre speeds. May be empty.
    #[prost(string, repeated, tag = "4")]
    pub speed: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfoSpecCompliance {
    /// List of supported ethernet types. May be empty.
    #[prost(string, repeated, tag = "1")]
    pub ethernet: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of supported SONET types. May be empty.
    #[prost(string, repeated, tag = "2")]
    pub sonet: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of supported SAS types. May be empty.
    #[prost(string, repeated, tag = "3")]
    pub sas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of supported GigaBit ethernet types. May be empty.
    #[prost(string, repeated, tag = "4")]
    pub gigabit_ethernet: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub fibre: ::core::option::Option<ModuleInfoSpecComplianceFibre>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfoDeviceIdentifier {
    #[prost(string, tag = "1")]
    pub identifier: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub revision_compliance: ::prost::alloc::string::String,
    /// List of supported upper pages (each byte is a page number).
    #[prost(bytes = "vec", tag = "3")]
    pub optional_upper_pages: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "4")]
    pub power_class: u32,
    #[prost(bool, tag = "5")]
    pub rx_cdr: bool,
    #[prost(bool, tag = "6")]
    pub tx_cdr: bool,
    #[prost(string, tag = "7")]
    pub connector_type: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub encoding: ::prost::alloc::string::String,
    /// in Megabaud
    #[prost(uint32, tag = "9")]
    pub baud_rate: u32,
    #[prost(message, optional, tag = "10")]
    pub spec_compliance: ::core::option::Option<ModuleInfoSpecCompliance>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfoDevice {
    #[prost(message, optional, tag = "1")]
    pub identifier: ::core::option::Option<ModuleInfoDeviceIdentifier>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfo {
    #[prost(message, optional, tag = "1")]
    pub vendor: ::core::option::Option<ModuleInfoVendor>,
    #[prost(message, optional, tag = "2")]
    pub device: ::core::option::Option<ModuleInfoDevice>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModuleInfoRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all modules.
    #[prost(sint32, tag = "2")]
    pub mod_id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfoResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub mod_id: u32,
    #[prost(message, optional, tag = "4")]
    pub info: ::core::option::Option<ModuleInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleMem {
    /// Offset into the 256 byte module memory. Memory is divided in 2 128 byte
    #[prost(uint32, tag = "1")]
    pub offset: u32,
    /// pages, where the lower page (bytes 0-127) are fixed and the upper page
    /// (bytes 128-255) are dynamically selected by the page index.
    ///
    /// Index used to select one of 256 possible dynamic upper memory pages. Only
    #[prost(uint32, tag = "2")]
    pub page: u32,
    /// needed when accessing bytes in the offset range 128-255.
    ///
    /// For get operations, indicates the number of bytes to read starting from
    #[prost(uint32, tag = "3")]
    pub count: u32,
    /// the given offset. Must not exceed 256 bytes (offset + count <= 256).
    /// Not used for set operations.
    ///
    /// Bytes returned on get operations or given for set operations.
    #[prost(bytes = "vec", tag = "4")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleMemRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all modules.
    #[prost(sint32, tag = "2")]
    pub mod_id: i32,
    #[prost(message, optional, tag = "3")]
    pub mem: ::core::option::Option<ModuleMem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleMemResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub mod_id: u32,
    /// Data returned on get operations. Will be unset for set operations.
    #[prost(message, optional, tag = "4")]
    pub mem: ::core::option::Option<ModuleMem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleStatusAlarm {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub active: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleStatusMonitor {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub value: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleStatus {
    #[prost(message, repeated, tag = "1")]
    pub alarms: ::prost::alloc::vec::Vec<ModuleStatusAlarm>,
    #[prost(message, repeated, tag = "2")]
    pub monitors: ::prost::alloc::vec::Vec<ModuleStatusMonitor>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModuleStatusRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all modules.
    #[prost(sint32, tag = "2")]
    pub mod_id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleStatusResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub mod_id: u32,
    #[prost(message, optional, tag = "4")]
    pub status: ::core::option::Option<ModuleStatus>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PortConfig {
    #[prost(enumeration = "PortState", tag = "1")]
    pub state: i32,
    #[prost(enumeration = "PortFec", tag = "2")]
    pub fec: i32,
    #[prost(enumeration = "PortLoopback", tag = "3")]
    pub loopback: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PortConfigRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all ports.
    #[prost(sint32, tag = "2")]
    pub port_id: i32,
    /// Configuration data used for set operations. Leave unset for get operations.
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<PortConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PortConfigResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub port_id: u32,
    /// Configuration data returned on get operations. Will be unset for set operations.
    #[prost(message, optional, tag = "4")]
    pub config: ::core::option::Option<PortConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PortStatus {
    #[prost(enumeration = "PortLink", tag = "1")]
    pub link: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PortStatusRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all ports.
    #[prost(sint32, tag = "2")]
    pub port_id: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PortStatusResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub port_id: u32,
    #[prost(message, optional, tag = "4")]
    pub status: ::core::option::Option<PortStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PortStatsRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// 0-based index. Set to -1 for all ports.
    #[prost(sint32, tag = "2")]
    pub port_id: i32,
    /// Filters to restrict statistics on get operations.
    #[prost(message, optional, tag = "3")]
    pub filters: ::core::option::Option<StatsFilters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PortStatsResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(uint32, tag = "3")]
    pub port_id: u32,
    #[prost(message, optional, tag = "4")]
    pub stats: ::core::option::Option<Stats>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwitchInterfaceId {
    #[prost(enumeration = "SwitchInterfaceType", tag = "1")]
    pub itype: i32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwitchProcessorId {
    #[prost(enumeration = "SwitchProcessorType", tag = "1")]
    pub ptype: i32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwitchIngressSource {
    #[prost(message, optional, tag = "1")]
    pub from_intf: ::core::option::Option<SwitchInterfaceId>,
    #[prost(message, optional, tag = "2")]
    pub to_intf: ::core::option::Option<SwitchInterfaceId>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwitchIngressConnection {
    #[prost(message, optional, tag = "1")]
    pub from_intf: ::core::option::Option<SwitchInterfaceId>,
    #[prost(message, optional, tag = "2")]
    pub to_proc: ::core::option::Option<SwitchProcessorId>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwitchEgressConnection {
    #[prost(message, optional, tag = "1")]
    pub on_proc: ::core::option::Option<SwitchProcessorId>,
    #[prost(message, optional, tag = "2")]
    pub from_intf: ::core::option::Option<SwitchInterfaceId>,
    #[prost(message, optional, tag = "3")]
    pub to_intf: ::core::option::Option<SwitchInterfaceId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchConfig {
    /// Array containing one source mapping per ingress interface.
    #[prost(message, repeated, tag = "1")]
    pub ingress_sources: ::prost::alloc::vec::Vec<SwitchIngressSource>,
    /// Array containing one connection mapping per ingress interface.
    #[prost(message, repeated, tag = "2")]
    pub ingress_connections: ::prost::alloc::vec::Vec<SwitchIngressConnection>,
    /// Array containing one connection mapping per egress interface on each processor.
    #[prost(message, repeated, tag = "3")]
    pub egress_connections: ::prost::alloc::vec::Vec<SwitchEgressConnection>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchConfigRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// Configuration data used for set operations. Leave unset for get operations.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<SwitchConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchConfigResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    /// Configuration data returned on get operations. Will be unset for set operations.
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<SwitchConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchStatsRequest {
    /// 0-based index. Set to -1 for all devices.
    #[prost(sint32, tag = "1")]
    pub dev_id: i32,
    /// Filters to restrict statistics on get operations.
    #[prost(message, optional, tag = "2")]
    pub filters: ::core::option::Option<StatsFilters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchStatsResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(uint32, tag = "2")]
    pub dev_id: u32,
    #[prost(message, optional, tag = "3")]
    pub stats: ::core::option::Option<Stats>,
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerStatus {
    /// UTC wall clock.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Diff of monotonic system clock.
    #[prost(message, optional, tag = "2")]
    pub up_time: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerStatusRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerStatusResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<ServerStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerDebug {
    #[prost(enumeration = "ServerDebugFlag", repeated, tag = "1")]
    pub enables: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "ServerDebugFlag", repeated, tag = "2")]
    pub disables: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerControlStats {
    #[prost(enumeration = "ServerControlStatsFlag", repeated, tag = "1")]
    pub enables: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "ServerControlStatsFlag", repeated, tag = "2")]
    pub disables: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerControl {
    #[prost(message, optional, tag = "1")]
    pub stats: ::core::option::Option<ServerControlStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfig {
    #[prost(message, optional, tag = "1")]
    pub debug: ::core::option::Option<ServerDebug>,
    #[prost(message, optional, tag = "2")]
    pub control: ::core::option::Option<ServerControl>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfigRequest {
    /// Configuration data used for set operations. Leave unset for get operations.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<ServerConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfigResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    /// Configuration data returned on get operations. Will be unset for set operations.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<ServerConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchRequest {
    #[prost(enumeration = "BatchOperation", tag = "1")]
    pub op: i32,
    #[prost(
        oneof = "batch_request::Item",
        tags = "10, 11, 20, 21, 30, 31, 32, 40, 41, 50, 60, 70, 71, 72, 73, 80, 81"
    )]
    pub item: ::core::option::Option<batch_request::Item>,
}
/// Nested message and enum types in `BatchRequest`.
pub mod batch_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        /// General device configuration.
        #[prost(message, tag = "10")]
        DeviceInfo(super::DeviceInfoRequest),
        #[prost(message, tag = "11")]
        DeviceStatus(super::DeviceStatusRequest),
        /// Host configuration.
        #[prost(message, tag = "20")]
        HostConfig(super::HostConfigRequest),
        #[prost(message, tag = "21")]
        HostStats(super::HostStatsRequest),
        /// Port configuration.
        #[prost(message, tag = "30")]
        PortConfig(super::PortConfigRequest),
        #[prost(message, tag = "31")]
        PortStatus(super::PortStatusRequest),
        #[prost(message, tag = "32")]
        PortStats(super::PortStatsRequest),
        /// Switch configuration.
        #[prost(message, tag = "40")]
        SwitchConfig(super::SwitchConfigRequest),
        #[prost(message, tag = "41")]
        SwitchStats(super::SwitchStatsRequest),
        /// Preset defaults configuration.
        #[prost(message, tag = "50")]
        Defaults(super::DefaultsRequest),
        /// Statistics configuration.
        #[prost(message, tag = "60")]
        Stats(super::StatsRequest),
        /// Module configuration.
        #[prost(message, tag = "70")]
        ModuleInfo(super::ModuleInfoRequest),
        #[prost(message, tag = "71")]
        ModuleStatus(super::ModuleStatusRequest),
        #[prost(message, tag = "72")]
        ModuleMem(super::ModuleMemRequest),
        #[prost(message, tag = "73")]
        ModuleGpio(super::ModuleGpioRequest),
        /// Server configuration.
        #[prost(message, tag = "80")]
        ServerStatus(super::ServerStatusRequest),
        #[prost(message, tag = "81")]
        ServerConfig(super::ServerConfigRequest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchResponse {
    /// Must be EC_OK before accessing remaining fields.
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub error_code: i32,
    #[prost(enumeration = "BatchOperation", tag = "2")]
    pub op: i32,
    #[prost(
        oneof = "batch_response::Item",
        tags = "10, 11, 20, 21, 30, 31, 32, 40, 41, 50, 60, 70, 71, 72, 73, 80, 81"
    )]
    pub item: ::core::option::Option<batch_response::Item>,
}
/// Nested message and enum types in `BatchResponse`.
pub mod batch_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        /// General device configuration.
        #[prost(message, tag = "10")]
        DeviceInfo(super::DeviceInfoResponse),
        #[prost(message, tag = "11")]
        DeviceStatus(super::DeviceStatusResponse),
        /// Host configuration.
        #[prost(message, tag = "20")]
        HostConfig(super::HostConfigResponse),
        #[prost(message, tag = "21")]
        HostStats(super::HostStatsResponse),
        /// Port configuration.
        #[prost(message, tag = "30")]
        PortConfig(super::PortConfigResponse),
        #[prost(message, tag = "31")]
        PortStatus(super::PortStatusResponse),
        #[prost(message, tag = "32")]
        PortStats(super::PortStatsResponse),
        /// Switch configuration.
        #[prost(message, tag = "40")]
        SwitchConfig(super::SwitchConfigResponse),
        #[prost(message, tag = "41")]
        SwitchStats(super::SwitchStatsResponse),
        /// Preset defaults configuration.
        #[prost(message, tag = "50")]
        Defaults(super::DefaultsResponse),
        /// Statistics configuration.
        #[prost(message, tag = "60")]
        Stats(super::StatsResponse),
        /// Module configuration.
        #[prost(message, tag = "70")]
        ModuleInfo(super::ModuleInfoResponse),
        #[prost(message, tag = "71")]
        ModuleStatus(super::ModuleStatusResponse),
        #[prost(message, tag = "72")]
        ModuleMem(super::ModuleMemResponse),
        #[prost(message, tag = "73")]
        ModuleGpio(super::ModuleGpioResponse),
        /// Server configuration.
        #[prost(message, tag = "80")]
        ServerStatus(super::ServerStatusResponse),
        #[prost(message, tag = "81")]
        ServerConfig(super::ServerConfigResponse),
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    /// General error codes.
    ///
    /// Field is unset.
    EcUnknown = 0,
    EcOk = 1,
    /// Batch error codes.
    EcUnknownBatchRequest = 100,
    EcUnknownBatchOp = 101,
    /// Device configuration error codes.
    EcInvalidDeviceId = 200,
    EcCardInfoReadFailed = 201,
    /// Host configuration error codes.
    EcInvalidHostId = 300,
    EcMissingHostConfig = 301,
    EcMissingHostDmaConfig = 302,
    EcUnsupportedHostId = 303,
    EcFailedGetDmaQueues = 304,
    EcFailedSetDmaQueues = 305,
    /// Port configuration error codes.
    EcInvalidPortId = 400,
    EcMissingPortConfig = 401,
    EcUnsupportedPortId = 402,
    EcUnsupportedPortState = 403,
    EcUnsupportedPortFec = 404,
    EcUnsupportedPortLoopback = 405,
    /// Switch configuration error codes.
    EcMissingSwitchConfig = 500,
    EcMissingIgrSrcFromIntf = 501,
    EcMissingIgrSrcToIntf = 502,
    EcUnsupportedIgrSrcFromIntf = 503,
    EcUnsupportedIgrSrcToIntf = 504,
    EcFailedGetIgrSrc = 505,
    EcFailedSetIgrSrc = 506,
    EcMissingIgrConnFromIntf = 507,
    EcMissingIgrConnToProc = 508,
    EcUnsupportedIgrConnFromIntf = 509,
    EcUnsupportedIgrConnToProc = 510,
    EcFailedGetIgrConn = 511,
    EcFailedSetIgrConn = 512,
    EcMissingEgrConnOnProc = 513,
    EcMissingEgrConnFromIntf = 514,
    EcMissingEgrConnToIntf = 515,
    EcUnsupportedEgrConnOnProc = 516,
    EcUnsupportedEgrConnFromIntf = 517,
    EcUnsupportedEgrConnToIntf = 518,
    EcFailedGetEgrConn = 519,
    EcFailedSetEgrConn = 520,
    /// Defaults configuration error codes.
    EcUnknownDefaultsProfile = 600,
    /// Module configuration error codes.
    EcInvalidModuleId = 700,
    EcModulePageReadFailed = 701,
    EcInvalidModuleMemOffset = 702,
    EcInvalidModuleMemPage = 703,
    EcInvalidModuleMemCount = 704,
    EcModuleMemReadFailed = 705,
    EcModuleMemWriteFailed = 706,
    EcUnknownModuleGpioType = 707,
    EcModuleGpioReadFailed = 708,
    EcModuleGpioWriteFailed = 709,
    EcModuleNotPresent = 710,
    /// Server configuration error codes.
    EcServerFailedGetTime = 800,
    EcServerInvalidDebugFlag = 801,
    EcServerInvalidControlStatsFlag = 802,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EcUnknown => "EC_UNKNOWN",
            Self::EcOk => "EC_OK",
            Self::EcUnknownBatchRequest => "EC_UNKNOWN_BATCH_REQUEST",
            Self::EcUnknownBatchOp => "EC_UNKNOWN_BATCH_OP",
            Self::EcInvalidDeviceId => "EC_INVALID_DEVICE_ID",
            Self::EcCardInfoReadFailed => "EC_CARD_INFO_READ_FAILED",
            Self::EcInvalidHostId => "EC_INVALID_HOST_ID",
            Self::EcMissingHostConfig => "EC_MISSING_HOST_CONFIG",
            Self::EcMissingHostDmaConfig => "EC_MISSING_HOST_DMA_CONFIG",
            Self::EcUnsupportedHostId => "EC_UNSUPPORTED_HOST_ID",
            Self::EcFailedGetDmaQueues => "EC_FAILED_GET_DMA_QUEUES",
            Self::EcFailedSetDmaQueues => "EC_FAILED_SET_DMA_QUEUES",
            Self::EcInvalidPortId => "EC_INVALID_PORT_ID",
            Self::EcMissingPortConfig => "EC_MISSING_PORT_CONFIG",
            Self::EcUnsupportedPortId => "EC_UNSUPPORTED_PORT_ID",
            Self::EcUnsupportedPortState => "EC_UNSUPPORTED_PORT_STATE",
            Self::EcUnsupportedPortFec => "EC_UNSUPPORTED_PORT_FEC",
            Self::EcUnsupportedPortLoopback => "EC_UNSUPPORTED_PORT_LOOPBACK",
            Self::EcMissingSwitchConfig => "EC_MISSING_SWITCH_CONFIG",
            Self::EcMissingIgrSrcFromIntf => "EC_MISSING_IGR_SRC_FROM_INTF",
            Self::EcMissingIgrSrcToIntf => "EC_MISSING_IGR_SRC_TO_INTF",
            Self::EcUnsupportedIgrSrcFromIntf => "EC_UNSUPPORTED_IGR_SRC_FROM_INTF",
            Self::EcUnsupportedIgrSrcToIntf => "EC_UNSUPPORTED_IGR_SRC_TO_INTF",
            Self::EcFailedGetIgrSrc => "EC_FAILED_GET_IGR_SRC",
            Self::EcFailedSetIgrSrc => "EC_FAILED_SET_IGR_SRC",
            Self::EcMissingIgrConnFromIntf => "EC_MISSING_IGR_CONN_FROM_INTF",
            Self::EcMissingIgrConnToProc => "EC_MISSING_IGR_CONN_TO_PROC",
            Self::EcUnsupportedIgrConnFromIntf => "EC_UNSUPPORTED_IGR_CONN_FROM_INTF",
            Self::EcUnsupportedIgrConnToProc => "EC_UNSUPPORTED_IGR_CONN_TO_PROC",
            Self::EcFailedGetIgrConn => "EC_FAILED_GET_IGR_CONN",
            Self::EcFailedSetIgrConn => "EC_FAILED_SET_IGR_CONN",
            Self::EcMissingEgrConnOnProc => "EC_MISSING_EGR_CONN_ON_PROC",
            Self::EcMissingEgrConnFromIntf => "EC_MISSING_EGR_CONN_FROM_INTF",
            Self::EcMissingEgrConnToIntf => "EC_MISSING_EGR_CONN_TO_INTF",
            Self::EcUnsupportedEgrConnOnProc => "EC_UNSUPPORTED_EGR_CONN_ON_PROC",
            Self::EcUnsupportedEgrConnFromIntf => "EC_UNSUPPORTED_EGR_CONN_FROM_INTF",
            Self::EcUnsupportedEgrConnToIntf => "EC_UNSUPPORTED_EGR_CONN_TO_INTF",
            Self::EcFailedGetEgrConn => "EC_FAILED_GET_EGR_CONN",
            Self::EcFailedSetEgrConn => "EC_FAILED_SET_EGR_CONN",
            Self::EcUnknownDefaultsProfile => "EC_UNKNOWN_DEFAULTS_PROFILE",
            Self::EcInvalidModuleId => "EC_INVALID_MODULE_ID",
            Self::EcModulePageReadFailed => "EC_MODULE_PAGE_READ_FAILED",
            Self::EcInvalidModuleMemOffset => "EC_INVALID_MODULE_MEM_OFFSET",
            Self::EcInvalidModuleMemPage => "EC_INVALID_MODULE_MEM_PAGE",
            Self::EcInvalidModuleMemCount => "EC_INVALID_MODULE_MEM_COUNT",
            Self::EcModuleMemReadFailed => "EC_MODULE_MEM_READ_FAILED",
            Self::EcModuleMemWriteFailed => "EC_MODULE_MEM_WRITE_FAILED",
            Self::EcUnknownModuleGpioType => "EC_UNKNOWN_MODULE_GPIO_TYPE",
            Self::EcModuleGpioReadFailed => "EC_MODULE_GPIO_READ_FAILED",
            Self::EcModuleGpioWriteFailed => "EC_MODULE_GPIO_WRITE_FAILED",
            Self::EcModuleNotPresent => "EC_MODULE_NOT_PRESENT",
            Self::EcServerFailedGetTime => "EC_SERVER_FAILED_GET_TIME",
            Self::EcServerInvalidDebugFlag => "EC_SERVER_INVALID_DEBUG_FLAG",
            Self::EcServerInvalidControlStatsFlag => {
                "EC_SERVER_INVALID_CONTROL_STATS_FLAG"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EC_UNKNOWN" => Some(Self::EcUnknown),
            "EC_OK" => Some(Self::EcOk),
            "EC_UNKNOWN_BATCH_REQUEST" => Some(Self::EcUnknownBatchRequest),
            "EC_UNKNOWN_BATCH_OP" => Some(Self::EcUnknownBatchOp),
            "EC_INVALID_DEVICE_ID" => Some(Self::EcInvalidDeviceId),
            "EC_CARD_INFO_READ_FAILED" => Some(Self::EcCardInfoReadFailed),
            "EC_INVALID_HOST_ID" => Some(Self::EcInvalidHostId),
            "EC_MISSING_HOST_CONFIG" => Some(Self::EcMissingHostConfig),
            "EC_MISSING_HOST_DMA_CONFIG" => Some(Self::EcMissingHostDmaConfig),
            "EC_UNSUPPORTED_HOST_ID" => Some(Self::EcUnsupportedHostId),
            "EC_FAILED_GET_DMA_QUEUES" => Some(Self::EcFailedGetDmaQueues),
            "EC_FAILED_SET_DMA_QUEUES" => Some(Self::EcFailedSetDmaQueues),
            "EC_INVALID_PORT_ID" => Some(Self::EcInvalidPortId),
            "EC_MISSING_PORT_CONFIG" => Some(Self::EcMissingPortConfig),
            "EC_UNSUPPORTED_PORT_ID" => Some(Self::EcUnsupportedPortId),
            "EC_UNSUPPORTED_PORT_STATE" => Some(Self::EcUnsupportedPortState),
            "EC_UNSUPPORTED_PORT_FEC" => Some(Self::EcUnsupportedPortFec),
            "EC_UNSUPPORTED_PORT_LOOPBACK" => Some(Self::EcUnsupportedPortLoopback),
            "EC_MISSING_SWITCH_CONFIG" => Some(Self::EcMissingSwitchConfig),
            "EC_MISSING_IGR_SRC_FROM_INTF" => Some(Self::EcMissingIgrSrcFromIntf),
            "EC_MISSING_IGR_SRC_TO_INTF" => Some(Self::EcMissingIgrSrcToIntf),
            "EC_UNSUPPORTED_IGR_SRC_FROM_INTF" => Some(Self::EcUnsupportedIgrSrcFromIntf),
            "EC_UNSUPPORTED_IGR_SRC_TO_INTF" => Some(Self::EcUnsupportedIgrSrcToIntf),
            "EC_FAILED_GET_IGR_SRC" => Some(Self::EcFailedGetIgrSrc),
            "EC_FAILED_SET_IGR_SRC" => Some(Self::EcFailedSetIgrSrc),
            "EC_MISSING_IGR_CONN_FROM_INTF" => Some(Self::EcMissingIgrConnFromIntf),
            "EC_MISSING_IGR_CONN_TO_PROC" => Some(Self::EcMissingIgrConnToProc),
            "EC_UNSUPPORTED_IGR_CONN_FROM_INTF" => {
                Some(Self::EcUnsupportedIgrConnFromIntf)
            }
            "EC_UNSUPPORTED_IGR_CONN_TO_PROC" => Some(Self::EcUnsupportedIgrConnToProc),
            "EC_FAILED_GET_IGR_CONN" => Some(Self::EcFailedGetIgrConn),
            "EC_FAILED_SET_IGR_CONN" => Some(Self::EcFailedSetIgrConn),
            "EC_MISSING_EGR_CONN_ON_PROC" => Some(Self::EcMissingEgrConnOnProc),
            "EC_MISSING_EGR_CONN_FROM_INTF" => Some(Self::EcMissingEgrConnFromIntf),
            "EC_MISSING_EGR_CONN_TO_INTF" => Some(Self::EcMissingEgrConnToIntf),
            "EC_UNSUPPORTED_EGR_CONN_ON_PROC" => Some(Self::EcUnsupportedEgrConnOnProc),
            "EC_UNSUPPORTED_EGR_CONN_FROM_INTF" => {
                Some(Self::EcUnsupportedEgrConnFromIntf)
            }
            "EC_UNSUPPORTED_EGR_CONN_TO_INTF" => Some(Self::EcUnsupportedEgrConnToIntf),
            "EC_FAILED_GET_EGR_CONN" => Some(Self::EcFailedGetEgrConn),
            "EC_FAILED_SET_EGR_CONN" => Some(Self::EcFailedSetEgrConn),
            "EC_UNKNOWN_DEFAULTS_PROFILE" => Some(Self::EcUnknownDefaultsProfile),
            "EC_INVALID_MODULE_ID" => Some(Self::EcInvalidModuleId),
            "EC_MODULE_PAGE_READ_FAILED" => Some(Self::EcModulePageReadFailed),
            "EC_INVALID_MODULE_MEM_OFFSET" => Some(Self::EcInvalidModuleMemOffset),
            "EC_INVALID_MODULE_MEM_PAGE" => Some(Self::EcInvalidModuleMemPage),
            "EC_INVALID_MODULE_MEM_COUNT" => Some(Self::EcInvalidModuleMemCount),
            "EC_MODULE_MEM_READ_FAILED" => Some(Self::EcModuleMemReadFailed),
            "EC_MODULE_MEM_WRITE_FAILED" => Some(Self::EcModuleMemWriteFailed),
            "EC_UNKNOWN_MODULE_GPIO_TYPE" => Some(Self::EcUnknownModuleGpioType),
            "EC_MODULE_GPIO_READ_FAILED" => Some(Self::EcModuleGpioReadFailed),
            "EC_MODULE_GPIO_WRITE_FAILED" => Some(Self::EcModuleGpioWriteFailed),
            "EC_MODULE_NOT_PRESENT" => Some(Self::EcModuleNotPresent),
            "EC_SERVER_FAILED_GET_TIME" => Some(Self::EcServerFailedGetTime),
            "EC_SERVER_INVALID_DEBUG_FLAG" => Some(Self::EcServerInvalidDebugFlag),
            "EC_SERVER_INVALID_CONTROL_STATS_FLAG" => {
                Some(Self::EcServerInvalidControlStatsFlag)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StatsMetricType {
    /// Field is unset.
    Unknown = 0,
    Counter = 1,
    Gauge = 2,
    Flag = 3,
}
impl StatsMetricType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "STATS_METRIC_TYPE_UNKNOWN",
            Self::Counter => "STATS_METRIC_TYPE_COUNTER",
            Self::Gauge => "STATS_METRIC_TYPE_GAUGE",
            Self::Flag => "STATS_METRIC_TYPE_FLAG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATS_METRIC_TYPE_UNKNOWN" => Some(Self::Unknown),
            "STATS_METRIC_TYPE_COUNTER" => Some(Self::Counter),
            "STATS_METRIC_TYPE_GAUGE" => Some(Self::Gauge),
            "STATS_METRIC_TYPE_FLAG" => Some(Self::Flag),
            _ => None,
        }
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DefaultsProfile {
    DsUnknown = 0,
    DsOneToOne = 1,
}
impl DefaultsProfile {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DsUnknown => "DS_UNKNOWN",
            Self::DsOneToOne => "DS_ONE_TO_ONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DS_UNKNOWN" => Some(Self::DsUnknown),
            "DS_ONE_TO_ONE" => Some(Self::DsOneToOne),
            _ => None,
        }
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModuleGpioState {
    GpioStateUnknown = 0,
    GpioStateAssert = 1,
    GpioStateDeassert = 2,
}
impl ModuleGpioState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GpioStateUnknown => "GPIO_STATE_UNKNOWN",
            Self::GpioStateAssert => "GPIO_STATE_ASSERT",
            Self::GpioStateDeassert => "GPIO_STATE_DEASSERT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GPIO_STATE_UNKNOWN" => Some(Self::GpioStateUnknown),
            "GPIO_STATE_ASSERT" => Some(Self::GpioStateAssert),
            "GPIO_STATE_DEASSERT" => Some(Self::GpioStateDeassert),
            _ => None,
        }
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PortState {
    /// Field is unset.
    Unknown = 0,
    Disable = 1,
    Enable = 2,
}
impl PortState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PORT_STATE_UNKNOWN",
            Self::Disable => "PORT_STATE_DISABLE",
            Self::Enable => "PORT_STATE_ENABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PORT_STATE_UNKNOWN" => Some(Self::Unknown),
            "PORT_STATE_DISABLE" => Some(Self::Disable),
            "PORT_STATE_ENABLE" => Some(Self::Enable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PortFec {
    /// Field is unset.
    Unknown = 0,
    None = 1,
    ReedSolomon = 2,
}
impl PortFec {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PORT_FEC_UNKNOWN",
            Self::None => "PORT_FEC_NONE",
            Self::ReedSolomon => "PORT_FEC_REED_SOLOMON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PORT_FEC_UNKNOWN" => Some(Self::Unknown),
            "PORT_FEC_NONE" => Some(Self::None),
            "PORT_FEC_REED_SOLOMON" => Some(Self::ReedSolomon),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PortLoopback {
    /// Field is unset.
    Unknown = 0,
    None = 1,
    NearEndPma = 2,
}
impl PortLoopback {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PORT_LOOPBACK_UNKNOWN",
            Self::None => "PORT_LOOPBACK_NONE",
            Self::NearEndPma => "PORT_LOOPBACK_NEAR_END_PMA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PORT_LOOPBACK_UNKNOWN" => Some(Self::Unknown),
            "PORT_LOOPBACK_NONE" => Some(Self::None),
            "PORT_LOOPBACK_NEAR_END_PMA" => Some(Self::NearEndPma),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PortLink {
    /// Field is unset.
    Unknown = 0,
    Down = 1,
    Up = 2,
}
impl PortLink {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PORT_LINK_UNKNOWN",
            Self::Down => "PORT_LINK_DOWN",
            Self::Up => "PORT_LINK_UP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PORT_LINK_UNKNOWN" => Some(Self::Unknown),
            "PORT_LINK_DOWN" => Some(Self::Down),
            "PORT_LINK_UP" => Some(Self::Up),
            _ => None,
        }
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SwitchInterfaceType {
    /// Field is unset.
    SwIntfUnknown = 0,
    SwIntfPort = 1,
    SwIntfHost = 2,
}
impl SwitchInterfaceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SwIntfUnknown => "SW_INTF_UNKNOWN",
            Self::SwIntfPort => "SW_INTF_PORT",
            Self::SwIntfHost => "SW_INTF_HOST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SW_INTF_UNKNOWN" => Some(Self::SwIntfUnknown),
            "SW_INTF_PORT" => Some(Self::SwIntfPort),
            "SW_INTF_HOST" => Some(Self::SwIntfHost),
            _ => None,
        }
    }
}
/// TODO: Should Processor be Pipeline instead? For consistency with the sn-p4 protobuf?
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SwitchProcessorType {
    /// Field is unset.
    SwProcUnknown = 0,
    SwProcBypass = 1,
    SwProcDrop = 2,
    SwProcApp = 3,
}
impl SwitchProcessorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SwProcUnknown => "SW_PROC_UNKNOWN",
            Self::SwProcBypass => "SW_PROC_BYPASS",
            Self::SwProcDrop => "SW_PROC_DROP",
            Self::SwProcApp => "SW_PROC_APP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SW_PROC_UNKNOWN" => Some(Self::SwProcUnknown),
            "SW_PROC_BYPASS" => Some(Self::SwProcBypass),
            "SW_PROC_DROP" => Some(Self::SwProcDrop),
            "SW_PROC_APP" => Some(Self::SwProcApp),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServerDebugFlag {
    DebugFlagUnknown = 0,
    DebugFlagBatch = 1,
}
impl ServerDebugFlag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DebugFlagUnknown => "DEBUG_FLAG_UNKNOWN",
            Self::DebugFlagBatch => "DEBUG_FLAG_BATCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEBUG_FLAG_UNKNOWN" => Some(Self::DebugFlagUnknown),
            "DEBUG_FLAG_BATCH" => Some(Self::DebugFlagBatch),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServerControlStatsFlag {
    CtrlStatsFlagUnknown = 0,
    CtrlStatsFlagDomainCounters = 1,
    CtrlStatsFlagDomainMonitors = 2,
    CtrlStatsFlagDomainModules = 3,
    CtrlStatsFlagZoneCardMonitors = 10,
    CtrlStatsFlagZoneSysmonMonitors = 20,
    CtrlStatsFlagZoneHostCounters = 30,
    CtrlStatsFlagZonePortCounters = 40,
    CtrlStatsFlagZoneSwitchCounters = 50,
    CtrlStatsFlagZoneModuleMonitors = 60,
}
impl ServerControlStatsFlag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CtrlStatsFlagUnknown => "CTRL_STATS_FLAG_UNKNOWN",
            Self::CtrlStatsFlagDomainCounters => "CTRL_STATS_FLAG_DOMAIN_COUNTERS",
            Self::CtrlStatsFlagDomainMonitors => "CTRL_STATS_FLAG_DOMAIN_MONITORS",
            Self::CtrlStatsFlagDomainModules => "CTRL_STATS_FLAG_DOMAIN_MODULES",
            Self::CtrlStatsFlagZoneCardMonitors => "CTRL_STATS_FLAG_ZONE_CARD_MONITORS",
            Self::CtrlStatsFlagZoneSysmonMonitors => {
                "CTRL_STATS_FLAG_ZONE_SYSMON_MONITORS"
            }
            Self::CtrlStatsFlagZoneHostCounters => "CTRL_STATS_FLAG_ZONE_HOST_COUNTERS",
            Self::CtrlStatsFlagZonePortCounters => "CTRL_STATS_FLAG_ZONE_PORT_COUNTERS",
            Self::CtrlStatsFlagZoneSwitchCounters => {
                "CTRL_STATS_FLAG_ZONE_SWITCH_COUNTERS"
            }
            Self::CtrlStatsFlagZoneModuleMonitors => {
                "CTRL_STATS_FLAG_ZONE_MODULE_MONITORS"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CTRL_STATS_FLAG_UNKNOWN" => Some(Self::CtrlStatsFlagUnknown),
            "CTRL_STATS_FLAG_DOMAIN_COUNTERS" => Some(Self::CtrlStatsFlagDomainCounters),
            "CTRL_STATS_FLAG_DOMAIN_MONITORS" => Some(Self::CtrlStatsFlagDomainMonitors),
            "CTRL_STATS_FLAG_DOMAIN_MODULES" => Some(Self::CtrlStatsFlagDomainModules),
            "CTRL_STATS_FLAG_ZONE_CARD_MONITORS" => {
                Some(Self::CtrlStatsFlagZoneCardMonitors)
            }
            "CTRL_STATS_FLAG_ZONE_SYSMON_MONITORS" => {
                Some(Self::CtrlStatsFlagZoneSysmonMonitors)
            }
            "CTRL_STATS_FLAG_ZONE_HOST_COUNTERS" => {
                Some(Self::CtrlStatsFlagZoneHostCounters)
            }
            "CTRL_STATS_FLAG_ZONE_PORT_COUNTERS" => {
                Some(Self::CtrlStatsFlagZonePortCounters)
            }
            "CTRL_STATS_FLAG_ZONE_SWITCH_COUNTERS" => {
                Some(Self::CtrlStatsFlagZoneSwitchCounters)
            }
            "CTRL_STATS_FLAG_ZONE_MODULE_MONITORS" => {
                Some(Self::CtrlStatsFlagZoneModuleMonitors)
            }
            _ => None,
        }
    }
}
/// --------------------------------------------------------------------------------------------------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BatchOperation {
    /// Field is unset.
    BopUnknown = 0,
    BopGet = 1,
    BopSet = 2,
    BopClear = 3,
}
impl BatchOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BopUnknown => "BOP_UNKNOWN",
            Self::BopGet => "BOP_GET",
            Self::BopSet => "BOP_SET",
            Self::BopClear => "BOP_CLEAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOP_UNKNOWN" => Some(Self::BopUnknown),
            "BOP_GET" => Some(Self::BopGet),
            "BOP_SET" => Some(Self::BopSet),
            "BOP_CLEAR" => Some(Self::BopClear),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod smartnic_config_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// --------------------------------------------------------------------------------------------------
    #[derive(Debug, Clone)]
    pub struct SmartnicConfigClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SmartnicConfigClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SmartnicConfigClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SmartnicConfigClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SmartnicConfigClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Batching of multiple RPCs.
        pub async fn batch(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::BatchRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BatchResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/Batch",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "Batch"));
            self.inner.streaming(req, path, codec).await
        }
        /// Preset defaults configuration.
        pub async fn set_defaults(
            &mut self,
            request: impl tonic::IntoRequest<super::DefaultsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DefaultsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/SetDefaults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "SetDefaults"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// General device configuration.
        pub async fn get_device_info(
            &mut self,
            request: impl tonic::IntoRequest<super::DeviceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DeviceInfoResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetDeviceInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetDeviceInfo"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_device_status(
            &mut self,
            request: impl tonic::IntoRequest<super::DeviceStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DeviceStatusResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetDeviceStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetDeviceStatus"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Host configuration.
        pub async fn get_host_config(
            &mut self,
            request: impl tonic::IntoRequest<super::HostConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HostConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetHostConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetHostConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn set_host_config(
            &mut self,
            request: impl tonic::IntoRequest<super::HostConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HostConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/SetHostConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "SetHostConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_host_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::HostStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HostStatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetHostStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetHostStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn clear_host_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::HostStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HostStatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/ClearHostStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "ClearHostStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Module configuration.
        pub async fn get_module_gpio(
            &mut self,
            request: impl tonic::IntoRequest<super::ModuleGpioRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ModuleGpioResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetModuleGpio",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetModuleGpio"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn set_module_gpio(
            &mut self,
            request: impl tonic::IntoRequest<super::ModuleGpioRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ModuleGpioResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/SetModuleGpio",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "SetModuleGpio"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_module_info(
            &mut self,
            request: impl tonic::IntoRequest<super::ModuleInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ModuleInfoResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetModuleInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetModuleInfo"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_module_mem(
            &mut self,
            request: impl tonic::IntoRequest<super::ModuleMemRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ModuleMemResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetModuleMem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetModuleMem"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn set_module_mem(
            &mut self,
            request: impl tonic::IntoRequest<super::ModuleMemRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ModuleMemResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/SetModuleMem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "SetModuleMem"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_module_status(
            &mut self,
            request: impl tonic::IntoRequest<super::ModuleStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ModuleStatusResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetModuleStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetModuleStatus"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Port configuration.
        pub async fn get_port_config(
            &mut self,
            request: impl tonic::IntoRequest<super::PortConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PortConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetPortConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetPortConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn set_port_config(
            &mut self,
            request: impl tonic::IntoRequest<super::PortConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PortConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/SetPortConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "SetPortConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_port_status(
            &mut self,
            request: impl tonic::IntoRequest<super::PortStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PortStatusResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetPortStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetPortStatus"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_port_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::PortStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PortStatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetPortStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetPortStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn clear_port_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::PortStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PortStatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/ClearPortStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "ClearPortStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Statistics configuration.
        pub async fn get_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::StatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn clear_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::StatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/ClearStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "ClearStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Switch configuration.
        pub async fn get_switch_config(
            &mut self,
            request: impl tonic::IntoRequest<super::SwitchConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SwitchConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetSwitchConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetSwitchConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn set_switch_config(
            &mut self,
            request: impl tonic::IntoRequest<super::SwitchConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SwitchConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/SetSwitchConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "SetSwitchConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_switch_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::SwitchStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SwitchStatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetSwitchStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetSwitchStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn clear_switch_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::SwitchStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SwitchStatsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/ClearSwitchStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "ClearSwitchStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Server configuration.
        pub async fn get_server_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ServerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ServerConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetServerConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetServerConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn set_server_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ServerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ServerConfigResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/SetServerConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "SetServerConfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_server_status(
            &mut self,
            request: impl tonic::IntoRequest<super::ServerStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ServerStatusResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sn_cfg.v1.SmartnicConfig/GetServerStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sn_cfg.v1.SmartnicConfig", "GetServerStatus"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod smartnic_config_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SmartnicConfigServer.
    #[async_trait]
    pub trait SmartnicConfig: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Batch method.
        type BatchStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::BatchResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Batching of multiple RPCs.
        async fn batch(
            &self,
            request: tonic::Request<tonic::Streaming<super::BatchRequest>>,
        ) -> std::result::Result<tonic::Response<Self::BatchStream>, tonic::Status>;
        /// Server streaming response type for the SetDefaults method.
        type SetDefaultsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DefaultsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Preset defaults configuration.
        async fn set_defaults(
            &self,
            request: tonic::Request<super::DefaultsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SetDefaultsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetDeviceInfo method.
        type GetDeviceInfoStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DeviceInfoResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// General device configuration.
        async fn get_device_info(
            &self,
            request: tonic::Request<super::DeviceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetDeviceInfoStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetDeviceStatus method.
        type GetDeviceStatusStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DeviceStatusResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_device_status(
            &self,
            request: tonic::Request<super::DeviceStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetDeviceStatusStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetHostConfig method.
        type GetHostConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::HostConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Host configuration.
        async fn get_host_config(
            &self,
            request: tonic::Request<super::HostConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetHostConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SetHostConfig method.
        type SetHostConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::HostConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn set_host_config(
            &self,
            request: tonic::Request<super::HostConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SetHostConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetHostStats method.
        type GetHostStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::HostStatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_host_stats(
            &self,
            request: tonic::Request<super::HostStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetHostStatsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the ClearHostStats method.
        type ClearHostStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::HostStatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn clear_host_stats(
            &self,
            request: tonic::Request<super::HostStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ClearHostStatsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetModuleGpio method.
        type GetModuleGpioStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ModuleGpioResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Module configuration.
        async fn get_module_gpio(
            &self,
            request: tonic::Request<super::ModuleGpioRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetModuleGpioStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SetModuleGpio method.
        type SetModuleGpioStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ModuleGpioResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn set_module_gpio(
            &self,
            request: tonic::Request<super::ModuleGpioRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SetModuleGpioStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetModuleInfo method.
        type GetModuleInfoStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ModuleInfoResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_module_info(
            &self,
            request: tonic::Request<super::ModuleInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetModuleInfoStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetModuleMem method.
        type GetModuleMemStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ModuleMemResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_module_mem(
            &self,
            request: tonic::Request<super::ModuleMemRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetModuleMemStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SetModuleMem method.
        type SetModuleMemStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ModuleMemResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn set_module_mem(
            &self,
            request: tonic::Request<super::ModuleMemRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SetModuleMemStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetModuleStatus method.
        type GetModuleStatusStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ModuleStatusResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_module_status(
            &self,
            request: tonic::Request<super::ModuleStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetModuleStatusStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetPortConfig method.
        type GetPortConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PortConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Port configuration.
        async fn get_port_config(
            &self,
            request: tonic::Request<super::PortConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetPortConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SetPortConfig method.
        type SetPortConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PortConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn set_port_config(
            &self,
            request: tonic::Request<super::PortConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SetPortConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetPortStatus method.
        type GetPortStatusStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PortStatusResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_port_status(
            &self,
            request: tonic::Request<super::PortStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetPortStatusStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetPortStats method.
        type GetPortStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PortStatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_port_stats(
            &self,
            request: tonic::Request<super::PortStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetPortStatsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the ClearPortStats method.
        type ClearPortStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PortStatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn clear_port_stats(
            &self,
            request: tonic::Request<super::PortStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ClearPortStatsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetStats method.
        type GetStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::StatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Statistics configuration.
        async fn get_stats(
            &self,
            request: tonic::Request<super::StatsRequest>,
        ) -> std::result::Result<tonic::Response<Self::GetStatsStream>, tonic::Status>;
        /// Server streaming response type for the ClearStats method.
        type ClearStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::StatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn clear_stats(
            &self,
            request: tonic::Request<super::StatsRequest>,
        ) -> std::result::Result<tonic::Response<Self::ClearStatsStream>, tonic::Status>;
        /// Server streaming response type for the GetSwitchConfig method.
        type GetSwitchConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SwitchConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Switch configuration.
        async fn get_switch_config(
            &self,
            request: tonic::Request<super::SwitchConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetSwitchConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SetSwitchConfig method.
        type SetSwitchConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SwitchConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn set_switch_config(
            &self,
            request: tonic::Request<super::SwitchConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SetSwitchConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetSwitchStats method.
        type GetSwitchStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SwitchStatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_switch_stats(
            &self,
            request: tonic::Request<super::SwitchStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetSwitchStatsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the ClearSwitchStats method.
        type ClearSwitchStatsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SwitchStatsResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn clear_switch_stats(
            &self,
            request: tonic::Request<super::SwitchStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ClearSwitchStatsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetServerConfig method.
        type GetServerConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ServerConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Server configuration.
        async fn get_server_config(
            &self,
            request: tonic::Request<super::ServerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetServerConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SetServerConfig method.
        type SetServerConfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ServerConfigResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn set_server_config(
            &self,
            request: tonic::Request<super::ServerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SetServerConfigStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetServerStatus method.
        type GetServerStatusStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ServerStatusResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn get_server_status(
            &self,
            request: tonic::Request<super::ServerStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetServerStatusStream>,
            tonic::Status,
        >;
    }
    /// --------------------------------------------------------------------------------------------------
    #[derive(Debug)]
    pub struct SmartnicConfigServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SmartnicConfigServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SmartnicConfigServer<T>
    where
        T: SmartnicConfig,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sn_cfg.v1.SmartnicConfig/Batch" => {
                    #[allow(non_camel_case_types)]
                    struct BatchSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::StreamingService<super::BatchRequest>
                    for BatchSvc<T> {
                        type Response = super::BatchResponse;
                        type ResponseStream = T::BatchStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::BatchRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::batch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/SetDefaults" => {
                    #[allow(non_camel_case_types)]
                    struct SetDefaultsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::DefaultsRequest>
                    for SetDefaultsSvc<T> {
                        type Response = super::DefaultsResponse;
                        type ResponseStream = T::SetDefaultsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DefaultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::set_defaults(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetDefaultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetDeviceInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetDeviceInfoSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::DeviceInfoRequest>
                    for GetDeviceInfoSvc<T> {
                        type Response = super::DeviceInfoResponse;
                        type ResponseStream = T::GetDeviceInfoStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeviceInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_device_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDeviceInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetDeviceStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetDeviceStatusSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::DeviceStatusRequest>
                    for GetDeviceStatusSvc<T> {
                        type Response = super::DeviceStatusResponse;
                        type ResponseStream = T::GetDeviceStatusStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeviceStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_device_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDeviceStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetHostConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetHostConfigSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::HostConfigRequest>
                    for GetHostConfigSvc<T> {
                        type Response = super::HostConfigResponse;
                        type ResponseStream = T::GetHostConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HostConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_host_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetHostConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/SetHostConfig" => {
                    #[allow(non_camel_case_types)]
                    struct SetHostConfigSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::HostConfigRequest>
                    for SetHostConfigSvc<T> {
                        type Response = super::HostConfigResponse;
                        type ResponseStream = T::SetHostConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HostConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::set_host_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetHostConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetHostStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetHostStatsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::HostStatsRequest>
                    for GetHostStatsSvc<T> {
                        type Response = super::HostStatsResponse;
                        type ResponseStream = T::GetHostStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HostStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_host_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetHostStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/ClearHostStats" => {
                    #[allow(non_camel_case_types)]
                    struct ClearHostStatsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::HostStatsRequest>
                    for ClearHostStatsSvc<T> {
                        type Response = super::HostStatsResponse;
                        type ResponseStream = T::ClearHostStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HostStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::clear_host_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClearHostStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetModuleGpio" => {
                    #[allow(non_camel_case_types)]
                    struct GetModuleGpioSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ModuleGpioRequest>
                    for GetModuleGpioSvc<T> {
                        type Response = super::ModuleGpioResponse;
                        type ResponseStream = T::GetModuleGpioStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModuleGpioRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_module_gpio(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetModuleGpioSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/SetModuleGpio" => {
                    #[allow(non_camel_case_types)]
                    struct SetModuleGpioSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ModuleGpioRequest>
                    for SetModuleGpioSvc<T> {
                        type Response = super::ModuleGpioResponse;
                        type ResponseStream = T::SetModuleGpioStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModuleGpioRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::set_module_gpio(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetModuleGpioSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetModuleInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetModuleInfoSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ModuleInfoRequest>
                    for GetModuleInfoSvc<T> {
                        type Response = super::ModuleInfoResponse;
                        type ResponseStream = T::GetModuleInfoStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModuleInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_module_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetModuleInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetModuleMem" => {
                    #[allow(non_camel_case_types)]
                    struct GetModuleMemSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ModuleMemRequest>
                    for GetModuleMemSvc<T> {
                        type Response = super::ModuleMemResponse;
                        type ResponseStream = T::GetModuleMemStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModuleMemRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_module_mem(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetModuleMemSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/SetModuleMem" => {
                    #[allow(non_camel_case_types)]
                    struct SetModuleMemSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ModuleMemRequest>
                    for SetModuleMemSvc<T> {
                        type Response = super::ModuleMemResponse;
                        type ResponseStream = T::SetModuleMemStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModuleMemRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::set_module_mem(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetModuleMemSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetModuleStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetModuleStatusSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ModuleStatusRequest>
                    for GetModuleStatusSvc<T> {
                        type Response = super::ModuleStatusResponse;
                        type ResponseStream = T::GetModuleStatusStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModuleStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_module_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetModuleStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetPortConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetPortConfigSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::PortConfigRequest>
                    for GetPortConfigSvc<T> {
                        type Response = super::PortConfigResponse;
                        type ResponseStream = T::GetPortConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PortConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_port_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPortConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/SetPortConfig" => {
                    #[allow(non_camel_case_types)]
                    struct SetPortConfigSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::PortConfigRequest>
                    for SetPortConfigSvc<T> {
                        type Response = super::PortConfigResponse;
                        type ResponseStream = T::SetPortConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PortConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::set_port_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetPortConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetPortStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetPortStatusSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::PortStatusRequest>
                    for GetPortStatusSvc<T> {
                        type Response = super::PortStatusResponse;
                        type ResponseStream = T::GetPortStatusStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PortStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_port_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPortStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetPortStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetPortStatsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::PortStatsRequest>
                    for GetPortStatsSvc<T> {
                        type Response = super::PortStatsResponse;
                        type ResponseStream = T::GetPortStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PortStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_port_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPortStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/ClearPortStats" => {
                    #[allow(non_camel_case_types)]
                    struct ClearPortStatsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::PortStatsRequest>
                    for ClearPortStatsSvc<T> {
                        type Response = super::PortStatsResponse;
                        type ResponseStream = T::ClearPortStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PortStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::clear_port_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClearPortStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetStatsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::StatsRequest>
                    for GetStatsSvc<T> {
                        type Response = super::StatsResponse;
                        type ResponseStream = T::GetStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/ClearStats" => {
                    #[allow(non_camel_case_types)]
                    struct ClearStatsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::StatsRequest>
                    for ClearStatsSvc<T> {
                        type Response = super::StatsResponse;
                        type ResponseStream = T::ClearStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::clear_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClearStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetSwitchConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetSwitchConfigSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::SwitchConfigRequest>
                    for GetSwitchConfigSvc<T> {
                        type Response = super::SwitchConfigResponse;
                        type ResponseStream = T::GetSwitchConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SwitchConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_switch_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSwitchConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/SetSwitchConfig" => {
                    #[allow(non_camel_case_types)]
                    struct SetSwitchConfigSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::SwitchConfigRequest>
                    for SetSwitchConfigSvc<T> {
                        type Response = super::SwitchConfigResponse;
                        type ResponseStream = T::SetSwitchConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SwitchConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::set_switch_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetSwitchConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetSwitchStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetSwitchStatsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::SwitchStatsRequest>
                    for GetSwitchStatsSvc<T> {
                        type Response = super::SwitchStatsResponse;
                        type ResponseStream = T::GetSwitchStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SwitchStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_switch_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSwitchStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/ClearSwitchStats" => {
                    #[allow(non_camel_case_types)]
                    struct ClearSwitchStatsSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::SwitchStatsRequest>
                    for ClearSwitchStatsSvc<T> {
                        type Response = super::SwitchStatsResponse;
                        type ResponseStream = T::ClearSwitchStatsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SwitchStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::clear_switch_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClearSwitchStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetServerConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetServerConfigSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ServerConfigRequest>
                    for GetServerConfigSvc<T> {
                        type Response = super::ServerConfigResponse;
                        type ResponseStream = T::GetServerConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServerConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_server_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServerConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/SetServerConfig" => {
                    #[allow(non_camel_case_types)]
                    struct SetServerConfigSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ServerConfigRequest>
                    for SetServerConfigSvc<T> {
                        type Response = super::ServerConfigResponse;
                        type ResponseStream = T::SetServerConfigStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServerConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::set_server_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetServerConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sn_cfg.v1.SmartnicConfig/GetServerStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetServerStatusSvc<T: SmartnicConfig>(pub Arc<T>);
                    impl<
                        T: SmartnicConfig,
                    > tonic::server::ServerStreamingService<super::ServerStatusRequest>
                    for GetServerStatusSvc<T> {
                        type Response = super::ServerStatusResponse;
                        type ResponseStream = T::GetServerStatusStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServerStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartnicConfig>::get_server_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServerStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SmartnicConfigServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sn_cfg.v1.SmartnicConfig";
    impl<T> tonic::server::NamedService for SmartnicConfigServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
